// public static class Sorting


/// <summary>
/// Сортировка методом выбора
/// </summary>
/// <param name="collection">Исходный массив</param>
/// <returns>Отсортированный массив массив</returns>
int[] SortSelection(int[] collection)
{
    int size = collection.Length;
    for (int i = 0; i < size - 1; i++)
    {
        int pos = i;
        for (int j = i + 1; j < size; j++)
        {
            if (collection[j] < collection[pos]) pos = j;
        }
        int temp = collection[i];
        collection[i] = collection[pos];
        collection[pos] = temp;
    }
    return collection;
}

var array = new int[] { 9, 6, 2, 0, 3, 1, 7, 5 };
Console.WriteLine(string.Join(' ', array));
SortSelection(array);
Console.WriteLine(string.Join(' ', array));

// [9, 6, 2, 0, 3, 1, 7, 5 ] => [0, 6, 2, 9, 3, 1, 7, 5 ] => [0, 1, 2, 9, 3, 6, 7, 5 ] => ...

// Оценка сложности данного алгоритма.
// Так как в цикле мы проходимся по массиву n - 1 раз каждый раз, пока не дойдем к конечному элементу
// и не поменяем их местами, здесь наблюдается следующее: первый цикл: n - 1, второй n - 2,
// третий: n - 3 ... предпоследний: 2, последний: 1. Получаем арифметическую прогрессию.
// Формула арифметической прогрессии: S = ((a1 + an)/2)*n или S = ((2a1 + d(n - 1))/2)*n.
// Но этот алгоритм мы можем наблюдать не просто как арифметическую прогрессию: если мы будем складывать
// первый и последний член массива, получим в сумме n, потом второй с предпоследним, опять сумма n,
// третий и третий с конца - сумма n, но при этом этих пар будет в 2 раза меньше, т.е. n / 2.
// Оценка сложности алгоритма получилась: n * n / 2 или (1/2)*n^2
// По 5 столпу (правилу) константу можно пренебречь
// Оценка сложности алгоритма: O(n^2). 